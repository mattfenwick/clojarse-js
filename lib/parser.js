"use strict";

var u = require('unparse-js'),
    C = u.combinators,
    Cst = u.cst;

var pos     = C.position,
    item    = pos.item,
    satisfy = pos.satisfy,
    node    = Cst.node,
    cut     = Cst.cut;
    
var many0 = C.many0,
    alt   = C.alt  , not0  = C.not0;


function tokentype(type) {
    return satisfy(function(t) {
        return t.tokentype === type;
    });
}

var myForm = new C.Parser(function() {}); // a 'forward declaration' -- not important what the arg is b/c it'll be replaced later

var myString   =  tokentype('string') , // should the fields be consistent with those generated by `node`?
    myNumber   =  tokentype('number') ,
    myChar     =  tokentype('char')   ,
    myNil      =  tokentype('nil')    ,
    myBoolean  =  tokentype('boolean'),
    mySymbol   =  tokentype('symbol') ,
    myRegex    =  tokentype('regex')  ,
    myKeyword  =  tokentype('keyword');

var myList = node('list',
        ['open', tokentype('open-paren')],
        ['body', many0(myForm)],
        ['close', cut('close', tokentype('close-paren'))]),
    
    myVector = node('vector',
        ['open', tokentype('open-square')],
        ['body', many0(myForm)],
        ['close', cut('close', tokentype('close-square'))]),
    
    mySet = node('set',
        ['open' , tokentype('open-set')],
        ['body' , many0(myForm)        ],
        ['close', cut('close', tokentype('close-curly'))]),
    
    keyVal = node('keyval',
        ['key'  , myForm],
        ['value', cut('value', myForm)]),
    
    myTable = node('table',
        ['open-curly', tokentype('open-curly')],
        ['body'      , keyVal                 ],
        ['close'     , cut('close', tokentype('close-curly'))]);


var myFunction = node('function',
        ['open', tokentype('open-fn')],
        ['body', many0(myForm)],
        ['close', cut('close', tokentype('close-paren'))]),
    
    myQuote = node('quote',
        ['open', tokentype('quote')],
        ['form', cut('form', myForm)]),
                   
    myDeref = node('deref',
        ['open', tokentype('at-sign')],
        ['form', cut('form', myForm)]),
    
    myUnquote = node('unquote',
        ['open', tokentype('unquote')],
        ['form', cut('form', myForm)]),
    
    myUnquoteSplicing = node('unquote-splicing',
        ['open', tokentype('unquote-splicing')],
        ['form', cut('form', myForm)]),

    mySyntaxQuote = node('syntax-quote',
        ['open', tokentype('syntax-quote')],
        ['form', cut('form', myForm)]),

    myMeta = node('meta',
        ['open', tokentype('meta')],
        ['form', alt(mySymbol, myString, myKeyword, myTable)]); // should there be a `cut` here?
        // ??? does it fail without error -- bad !!!
    
myForm.parse = alt(
        myString, myNumber, myChar, myNil,
        myBoolean, mySymbol, myKeyword, myRegex,
        myList, myVector, mySet, myTable,
        myFunction, myDeref, myQuote,
        myUnquote, myUnquoteSplicing,
        mySyntaxQuote, myMeta
    ).parse;
    
var clojure = node('clojure',
        ['forms', many0(myForm)],
        ['end', cut('end', not0(item))]);

module.exports = {

    'forms'   :  clojure, // ??? TODO change exported name?
    'form'    :  myForm,
    
    'string'  :  myString,
    'number'  :  myNumber,
    'char'    :  myChar,
    'nil'     :  myNil,
    'boolean' :  myBoolean,
    'symbol'  :  mySymbol,
    'keyword' :  myKeyword,
    'regex'   :  myRegex,
    
    'list'    :  myList,
    'vector'  :  myVector,
    'set'     :  mySet,
    'table'   :  myTable,
    'function':  myFunction,
    
    'quote'   :  myQuote,
    'deref'   :  myDeref,
    'unquote' :  myUnquote
};

